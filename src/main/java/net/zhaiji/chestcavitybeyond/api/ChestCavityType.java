package net.zhaiji.chestcavitybeyond.api;

import com.google.common.collect.HashMultimap;
import com.google.common.collect.Multimap;
import net.minecraft.core.Holder;
import net.minecraft.core.NonNullList;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.world.entity.EntityType;
import net.minecraft.world.entity.LivingEntity;
import net.minecraft.world.entity.ai.attributes.Attribute;
import net.minecraft.world.entity.ai.attributes.AttributeModifier;
import net.minecraft.world.entity.ai.attributes.AttributeSupplier;
import net.minecraft.world.entity.ai.attributes.DefaultAttributes;
import net.minecraft.world.item.Item;
import net.minecraft.world.item.ItemStack;
import net.minecraft.world.item.Items;
import net.zhaiji.chestcavitybeyond.ChestCavityBeyond;
import net.zhaiji.chestcavitybeyond.util.ChestCavityUtil;
import net.zhaiji.chestcavitybeyond.util.OrganAttributeUtil;

import java.util.*;

public class ChestCavityType {
    private final NonNullList<Item> organs = NonNullList.withSize(27, Items.AIR);

    private final Map<EntityType<?>, Map<Holder<Attribute>, Double>> defaultAttributes = new HashMap<>();

    private final Map<EntityType<?>, Map<Holder<Attribute>, AttributeModifier>> defaultModifiers = new HashMap<>();

    private final Map<Item, List<AttributeBonus>> attributeBonuses = new HashMap<>();

    private final List<AttributeBonus> typeDefaultBonuses = new ArrayList<>();

    private boolean needBreath = true;

    private boolean unopenable = false;

    private String unopenableMessage;

    /**
     * 计算胸腔类型属性默认值
     *
     * @param entityType 实体类型
     * @param modifiers  修饰符集合
     */
    private static void calculateValue(EntityType<? extends LivingEntity> entityType, Holder<Attribute> attribute, Collection<AttributeModifier> modifiers, Map<Holder<Attribute>, Double> defaultMap, Map<Holder<Attribute>, AttributeModifier> modifierMap) {
        double value = 0;
        double baseValue = 0;
        boolean hasAttribute = false;
        if (DefaultAttributes.hasSupplier(entityType)) {
            AttributeSupplier attributeSupplier = DefaultAttributes.getSupplier(entityType);
            if (attributeSupplier.hasAttribute(attribute)) {
                hasAttribute = true;
                value = baseValue = attributeSupplier.getValue(attribute);
            }
        }
        if (!hasAttribute) {
            defaultMap.put(attribute, 0D);
        }
        for (AttributeModifier modifier : modifiers) {
            if (modifier.operation() == AttributeModifier.Operation.ADD_VALUE) {
                value += modifier.amount();
            }
        }
        double copyValue = value;
        for (AttributeModifier modifier : modifiers) {
            if (modifier.operation() == AttributeModifier.Operation.ADD_MULTIPLIED_BASE) {
                value += copyValue * modifier.amount();
            }
        }
        for (AttributeModifier modifier : modifiers) {
            if (modifier.operation() == AttributeModifier.Operation.ADD_MULTIPLIED_TOTAL) {
                value *= 1 + modifier.amount();
            }
        }
        defaultMap.put(attribute, value);
        // 当属性不是本模组添加的属性时，给予默认属性调整修饰符
        if (!attribute.getKey().location().getNamespace().equals(ChestCavityBeyond.MOD_ID)) {
            modifierMap.put(attribute, OrganAttributeUtil.createAddValueModifier("default", baseValue - value));
        }
    }

    public NonNullList<Item> getOrgans() {
        return organs;
    }

    /**
     * 复制目标胸腔类型
     *
     * @param copyTarget 要复制属性的胸腔类型
     * @return 当前胸腔类型
     */
    public ChestCavityType copyWith(ChestCavityType copyTarget) {
        for (int i = 0; i < organs.size(); i++) {
            organs.set(i, copyTarget.organs.get(i));
        }
        attributeBonuses.putAll(copyTarget.attributeBonuses);
        typeDefaultBonuses.addAll(copyTarget.typeDefaultBonuses);
        this.needBreath = copyTarget.needBreath;
        this.unopenable = copyTarget.unopenable;
        this.unopenableMessage = copyTarget.unopenableMessage;
        return this;
    }

    /**
     * 为胸腔类型设置默认器官
     *
     * @param index 小于27
     * @param organ 器官
     * @return 胸腔类型
     */
    public ChestCavityType setOrgan(int index, Item organ) {
        organs.set(index, organ);
        return this;
    }

    /**
     * 为胸腔类型设置第一排默认器官
     *
     * @param index 0 ~ 8
     * @param organ 器官
     * @return 胸腔类型
     */
    public ChestCavityType setFirstRow(int index, Item organ) {
        return setOrgan(index, organ);
    }

    /**
     * 为胸腔类型设置第二排默认器官
     *
     * @param index 0 ~ 8
     * @param organ 器官
     * @return 胸腔类型
     */
    public ChestCavityType setSecondRow(int index, Item organ) {
        return setOrgan(index + 9, organ);
    }

    /**
     * 为胸腔类型设置第三排默认器官
     *
     * @param index 0 ~ 8
     * @param organ 器官
     * @return 胸腔类型
     */
    public ChestCavityType setThirdRow(int index, Item organ) {
        return setOrgan(index + 18, organ);
    }

    /**
     * 获取是否需要呼吸
     *
     * @return 是否需要呼吸
     */
    public boolean getNeedBreath() {
        return needBreath;
    }

    /**
     * 设置是否需要呼吸
     *
     * @param needBreath 是否需要呼吸
     * @return 胸腔类型
     */
    public ChestCavityType setNeedBreath(boolean needBreath) {
        this.needBreath = needBreath;
        return this;
    }

    /**
     * 获取物品的属性加成列表
     *
     * @param item 物品
     * @return 属性加成列表，如果没有则返回空列表
     */
    public List<AttributeBonus> getAttributeBonuses(Item item) {
        return attributeBonuses.getOrDefault(item, List.of());
    }

    /**
     * 为特定器官添加额外属性加成
     *
     * @param organ      提供加成的物品
     * @param attribute  要修改的属性
     * @param bonusValue 加成数值
     * @param operation  应用方式
     * @return 胸腔类型
     */
    public ChestCavityType addAttributeBonus(Item organ, Holder<Attribute> attribute, double bonusValue, AttributeModifier.Operation operation) {
        attributeBonuses.computeIfAbsent(organ, item -> new ArrayList<>())
                .add(new AttributeBonus(attribute, bonusValue, operation));
        return this;
    }

    /**
     * 批量添加简单加成
     *
     * @param item       提供加成的物品
     * @param attributes 属性到加成数值的映射
     * @return 胸腔类型
     */
    public ChestCavityType addValueBonuses(Item item, Map<Holder<Attribute>, Double> attributes) {
        attributes.forEach((attribute, value) ->
                addAttributeBonus(item, attribute, value, AttributeModifier.Operation.ADD_VALUE)
        );
        return this;
    }

    /**
     * 为胸腔类型添加默认属性加成
     * 这些加成将应用于所有拥有此胸腔类型的实体，独立于器官系统
     *
     * @param attribute  要修改的属性
     * @param bonusValue 加成数值
     * @param operation  应用方式
     * @return 胸腔类型
     */
    public ChestCavityType addTypeDefaultBonus(Holder<Attribute> attribute, double bonusValue, AttributeModifier.Operation operation) {
        typeDefaultBonuses.add(new AttributeBonus(attribute, bonusValue, operation));
        return this;
    }

    /**
     * 批量添加简单的加值加成
     *
     * @param attributes 属性到加成数值的映射
     * @return 胸腔类型
     */
    public ChestCavityType addTypeValueBonuses(Map<Holder<Attribute>, Double> attributes) {
        attributes.forEach((attribute, value) ->
                addTypeDefaultBonus(attribute, value, AttributeModifier.Operation.ADD_VALUE)
        );
        return this;
    }

    /**
     * 获取胸腔类型的默认属性加成
     *
     * @return 默认属性加成列表
     */
    public List<AttributeBonus> getTypeDefaultBonuses() {
        return Collections.unmodifiableList(typeDefaultBonuses);
    }

    /**
     * 为每个属于这个胸腔类型的实体类型计算默认胸腔属性
     *
     * @param entityType 实体类型
     * @return 胸腔类型
     */
    public ChestCavityType builder(EntityType<? extends LivingEntity> entityType) {
        Multimap<Holder<Attribute>, AttributeModifier> modifierMultimap = HashMultimap.create();
        Map<Holder<Attribute>, Double> attributeMap = new HashMap<>();
        Map<Holder<Attribute>, AttributeModifier> modifierMap = new HashMap<>();

        // 收集器官的所有修饰符
        for (int i = 0; i < organs.size(); i++) {
            Item organItem = organs.get(i);
            if (organItem == Items.AIR) continue;
            ItemStack organ = organItem.getDefaultInstance();
            ResourceLocation slotId = ChestCavityUtil.getSlotId(i);
            // 器官默认属性
            modifierMultimap.putAll(
                    ChestCavityUtil.getOrganCap(organ)
                            .getAttributeModifiers(new ChestCavitySlotContext(null, null, slotId, i, organ))
            );
            // 器官补偿属性
            if (attributeBonuses.containsKey(organItem)) {
                for (AttributeBonus bonus : attributeBonuses.get(organItem)) {
                    modifierMultimap.put(bonus.attribute(), bonus.create(slotId));
                }
            }
        }

        // 添加胸腔类型默认加成
        for (AttributeBonus bonus : typeDefaultBonuses) {
            modifierMultimap.put(bonus.attribute(), bonus.create(ChestCavityBeyond.of("type_default")));
        }

        // 计算最终值
        for (Holder<Attribute> attribute : modifierMultimap.keySet()) {
            calculateValue(entityType, attribute, modifierMultimap.get(attribute), attributeMap, modifierMap);
        }
        defaultAttributes.put(entityType, attributeMap);
        defaultModifiers.put(entityType, modifierMap);
        return this;
    }

    /**
     * 获取实体类型的默认胸腔属性
     *
     * @param entityType 实体类型
     * @return 默认胸腔属性
     */
    public Map<Holder<Attribute>, Double> getDefaultAttributes(EntityType<?> entityType) {
        return defaultAttributes.get(entityType);
    }

    /**
     * 获取实体类型的默认属性调整修饰符
     *
     * @param entityType 实体类型
     * @return 默认属性调整修饰符
     */
    public Map<Holder<Attribute>, AttributeModifier> getDefaultModifier(EntityType<?> entityType) {
        return defaultModifiers.get(entityType);
    }

    /**
     * 获取是否不可开胸
     */
    public boolean isUnopenable() {
        return unopenable;
    }

    /**
     * 设置是否不可开胸
     */
    public ChestCavityType setUnopenable(boolean unopenable) {
        this.unopenable = unopenable;
        return this;
    }

    /**
     * 设置不可开胸时的消息提示（语言键）
     * @param messageKey 翻译键，如 "message.chestcavitybeyond.boss_undying"
     */
    public ChestCavityType setUnopenableMessage(String messageKey) {
        this.unopenableMessage = messageKey;
        return this;
    }

    /**
     * 获取不可开胸消息键
     */
    public String getUnopenableMessage() {
        return unopenableMessage;
    }
}
